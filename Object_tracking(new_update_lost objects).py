# -*- coding: utf-8 -*-
"""Object Tracking_v9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OS6QCXhDq_TR0J67D2AFjzbbrzCT-QP1

*Next Feed it into a very MOG2 video (have one)
"""

#This is the list of existing Points tracked (EPt) (i.e previous frame)
#This will be initiated as an empty dictionary
from scipy import spatial
EPt = {0: [1, 5], 1: [2, 6], 2: [3, 7], 3: [4, 8], 4: [5, 9], 5: [6, 10], 6: [7, 11]}

#This creates a new list of lists (EPt1) that Euclidian distance calculations are done on
#return the values #https://stackoverflow.com/questions/16228248/how-can-i-get-list-of-values-from-dict
EPtl = [*EPt.values()]
#type(EPtl)
EPtl

# Npt = Latest centroids from current frame, so another list of list.
Npt = [[4,8.1],[1.5,5.1],[10,11],[55,55]]

#Logic uses a KD tree - which essentially creates search tree (existing points in last frame), for a second set of coordinate (new frame )
#The code immediately below filters dictionaries based on keys
##https://stackoverflow.com/questions/3420122/filter-dict-to-contain-only-certain-keys
dictfiltkeep = lambda x, y: dict([ (i,x[i]) for i in x if i in set(y) ])
dictfiltDiscard = lambda x, y: dict([ (i,x[i]) for i in x if i not in set(y) ])

#Now I create various lists and dictionaries to hold temp datasets used to identify various points of interest
newobjectKeys =[]
UpdatedExistingPoints =[]
updateddic = {}
newpts ={}

#n is essentially a frame counter
n=0
for i in Npt:
  print("This new point: ",Npt[n],"is closest to this existing point:", EPtl[spatial.KDTree(EPtl).query(i)[1]])
  distance,index = spatial.KDTree(EPtl).query(i)
  print("The distance between the two points is ", distance, "and the index of the closest pt is ",index,)

  #This identifies objects that are within 2 units of each other in subsequent frames.
  #I assume that these are the same object. Kalman filters, and class based CNNs could make this more accurate.
  
  if distance <= 2:
    print("This is existing object so I need to update the coordinates of that object in the Existing Tracked Points list")
    updatedCoordinate = {index: Npt[n]}
    print("here is the updated coordinate")
    print(updatedCoordinate)
    updateddic.update(updatedCoordinate)
    #Now - here I add the dictionary index to the list. I will use this list to filter the Existing points dictionary latter.  that I can use for a filter .
    UpdatedExistingPoints.append(index)
    
  elif distance >2:
    print("This is a new object-I need to create a key to go with the coordinates values and add to the existing Points Tracked dictionary")
    print("This is the maximum key value from EPt dictionary- for newly appeared points, this + 1 is there Key")
    print(max(EPt, key=int)+1)
    incrKey = max(EPt, key=int)+1
    newlytrackedObs = {incrKey :i}
    print("now create list of new objects keys")
    newobjectKeys.append(incrKey)
    print("here are the new objects for this frame")
    print(newlytrackedObs)
    newpts.update(newlytrackedObs)
    
    #"Now I clear the newlytrackobjects so it can be reused")
    newlytrackedObs.clear()
    print("  ")

  n=n+1

print("Here is the centroids for the last frames tracked objects")
print(EPt)  
print("  ")  

print("Here is the dictionary of updated centroids")
print(updateddic)
print("  ")

print("here are the new pts for this frame")
print(newpts)
print("  ")

#print("Here are the pts to track in next frame")
itemstotrack  = {**updateddic, **newpts}

print("here are the keys for the points to track in next frame")
print(list(itemstotrack.keys()))

print("Lost centroids ")
lost = dictfiltDiscard(EPt, list(itemstotrack.keys()))
print(lost)

print("Here are the existing points tracked ready for the next frame")
EPt = itemstotrack
print(EPt)